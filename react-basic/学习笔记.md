## JSX
在JS代码中编写HTML的模版结构
* 所有标签都必须闭合
* 必须被一个父元素包裹
> JSX是JS的语法扩展，需要使用解析工具做解析之后才能在浏览器运行

* JS编译网站: https://babeljs.io

### JSX高频场景

#### JSX中使用JS表达式
通过大括号语法`{}`识别JS中的表达式(常见的变量、函数调用、方法调用、JS对象等)。

### JSX列表渲染

### JSX实现条件渲染
1. 通过逻辑与运算符&&
2. 使用三元表达式(a?b:c)

### JSX实现复杂条件渲染
自定义语句+if函数判断

## Reacr基础事件绑定
* 和JS基本一致(on+事件名称)

* 如果需要调用自定义参数，JSX中需要使用括号函数的写法
```jsx
<button onClick={() => handleCLick2("Dennis")}>click2 me</button>
```
* 同时需要自定义参数和事件对象参数
```jsx
const handleCLick2 = (name, e) => {
  console.log(name, e);
  // 顺序要保持一致
}
<button onClick={(e) => handleCLick2("Dennis", e)}>click2 me</button>
```

## React组件
一个组件就是一个用户界面的一部分，可以有自己的逻辑和外观，组件之间可以相互嵌套，也可以重复使用多次

在React中，一个组件就是**首字母大写的函数**，内部存放了组件的逻辑和视图UI，渲染组件只需要把组件**当成标签书写**即可。
* 也可以使用箭头函数

## useState基础使用
useState是一个React Hook（函数），它允许我们向组件添加一个**状态变量**，从而控制影响组件的渲染效果
* 数据驱动视图，状态变量一旦发生变化，组件的视图UI也会跟着发生变化
```jsx
const [count, setCount] = useState(0);
// useState是一个函数，返回值是一个数组
// 数组中的第一个参数时状态变量，第二个参数时set函数，用来修改状态变量
// useState的参数将作为参数count的初始值
```

### 修改状态的规则
#### 状态不可变
状态是只读的，应该始终是**替换它而不是修改它**

#### 修改对象状态
对于对象类型的状态变量，应该始终传给set方法一个**全新的对象**来进行修改（和前面的逻辑一样，必须使用set方法修改状态变量）
```jsx
const [form, setForm] = useState({
  name: "Dennis",
});
const handleCLick4 = () => {
  setCount({
    ...form,
    name: "Yue"
  });
};
```

#### 组件的样式处理
行内样式控制和类名样式控制
* 推荐使用css的`class`类名进行控制

### classnames优化类名控制
非常方便的通过条件动态控制class类名的显示
```js
className = { classNames('nav-item', { active: type === item.type }) };
```

## 受控表单绑定
使用react组件(useState)的状态控制表单的状态。
```jsx
const [value, setValue] = useState("");

<input
 type = "text"
 value = { value }
 onChange = { (e) => setValue(e.target.value) }
/>
```

## React中获取DOM
需要使用useRef钩子函数获取/操作DOM, 分为两步:
1. 使用useRef创建ref对象，并与JSX绑定
2. 在DOM可用时，通过inputRef.current属性拿到DOM对象
```jsx
const inputRef = useRef(null);

<input type="text" ref = {inputRef} />

console.log(inputRef.current);
```

## 组件通信
组件之间的数据传递，根据组件嵌套关系的不同，有不同的通信方法
### 父子通信
#### 父传子
父组件传递数据
子组件接受数据，使用props参数，props是一个对象，包含父组件传递过来的所有数据
```jsx
import { useState, useRef } from 'react'

// 父组件传递数据
// 子组件接受数据，使用props.name接收

function Son(props) {
  
  console.log(props)
  return (
    <div>
      this is son, {props.name}, {props.obj}
    </div>
  )
}

function App() {
  const name = 'this is app name';
  return (
    <div className="App">
      <Son 
        name = {name} 
        age = {18}
        list = {'vue', 'react'}
        obj = {{name: 'jack'}}
        child = {<span></span>}
      />
    </div>
  );
}

export default App;
```

* props可以传递任意的数据
  * 数组，字符串，对象，JSX等
* props是只读对象
  * 子组件只能读取props中的数据，不能直接进行修改，父组件的数据只能由父组件修改

#### 特殊的prop children
当我们在子组件中的标签内嵌套内容时，父组件会自动在名为children的prop属性中接收该内容
```jsx
function Son(props) {
  return (
    <div>
      <span>{props.children}</span>
    </div>
  )
}

function App() {
  return (
    <div className="App">
      <Son>
        <span>this is span</span>
      </Son>
    </div>
  );
}
```

#### 子传父
将子组件中的数据传递给父组件
1. 在子组件中调用父组件的函数，传递实参
2. 在父组件中使用useState获取子组件中的数据
```jsx
// 在子组件中调用父组件的函数，并传递参数

function Son({onGetSonMsg}) {
  const sonMsg = 'this is son msg';
  return (
    <div>
      this is Son
      <button onClick={() => onGetSonMsg(sonMsg)}>sedMsg</button>
    </div>
  )
}

function App() {
  // 使用useState接收子组件的数据
  const [msg, setMsg] = useState('');
  const getMsg = (msg) => {
    console.log(msg);
    setMsg(msg); // 获取子组件传递进来的数据，存贮到状态变量中
  }
  return (
    <div className="App">
      this is App, {msg}
      {/* 获取父组件的方法 */}
      <Son onGetSonMsg={getMsg}></Son>
    </div>
  );
}
```

### 兄弟通信
* 使用状态提升实现兄弟组件通信
  * 借用状态提升机制，通过父组件进行兄弟组件之间的数据传递
  * A子传父，父传B子，从而实现A传B

### 跨层通信
* 使用Context机制跨层级组件通信
  * 使用createContext方法创建一个上下文对象Ctx
  * 在顶层组件中通过Ctx.Provider组件提供数据
  * 在底层组件中通过useContext钩子函数获得数据
```jsx
// 1. 使用createContext创建上下文对象
const MsgContext = createContext();

// 2. 在顶层组件中使用Provide提供数据

// 3. 在底层组件中使用useContext钩子函数获得数据


function A () {
  return (
    <div>
      this is A componet
      <B></B>
    </div>
  )
}

function B () {
  const msg = useContext(MsgContext);
  return (
    <div>
      this is B componet, {msg}
    </div>
  )
}

function App() {
  const msg = 'this is App msg';
  
  return (
    <div className="App">
      {/* 通过value接收数据 */}
      <MsgContext.Provider value={msg}>
        this is App
        <A></A>
      </MsgContext.Provider>
    </div>
  );
}
```

## useEffect
一个React Hook函数用于在React组件中创建不是有事件引起而是有渲染本身引起的操作，比如发送AJAX请求，更改DOM等。
* 比如在组件渲染完成之后，向服务器要数据的动作
```jsx
useEffect(
  // 副作用函数，在函数内部可以放置要执行的操作
  () => {}, 
  // 可选参数，在数组里面放置依赖项，不同依赖项会影响第一个参数函数的执行
  // 为空时，函数只会请求一次
  []
)
```

### useEffect依赖参数说明
* 没有依赖项: 组件初始渲染+组件更新时执行
* 空数组依赖项: 只在初始渲染时执行一次
* 添加特性依赖项: 组件初始渲染+特性依赖变化时执行
```jsx

function App() {

  const [count, setCount] = useState(0);
  const [count1, setCount1] = useState(0);
  // 情况1，没有依赖项
  // 只要组件内有更新，都会执行
  // useEffect(() => {
  //   console.log("副作用函数执行了!");
  // }, [])

  // 情况2，空数组依赖项
  // 只在组件更新时执行
  // useEffect(() => {
  //   console.log("副作用函数执行了!");
  // }, [])

  // 情况3，特定依赖项
  // 只在组件更新时, 以及特定依赖项更新时执行
  useEffect(() => {
    console.log("副作用函数执行了!");
  }, [count1])
  return (
    <div className="App">
      this is App
      <button onClick={() => setCount(count+1)}>+{count}</button>
      <button onClick={() => setCount1(count1+1)}>+{count1}</button>
    </div>
  );
}
```


### 清除副作用
在useEfeect中编写的有渲染本身引起的对接组件间外部的操作，社区经常把它叫做副作用操作。
* 清除副作用最长用的时候是卸载组件
```jsx
useEffect(() => {
  // 实现副作用操作逻辑
  ...
  return () => {
    // 清除副作用逻辑

  }

}, [])
```